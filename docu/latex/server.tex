\section{Server}
Der Client stellt eine Verbindung zum Server her. Es werden bein starten des Client die Server- und Logindaten angegeben.

\subsection{Module}
\begin{itemize}
	\item Login-Thread
	\item Broadcasting-Agent
	\item Client-Thread
	\item Clientliste/Benutzerverwaltung/Rechteabfrage
	\item Tafel + Zugriffsfunktionen
	\item Schnittstelle: Server <-> Logger Kommunikation
	\item Schnittstelle: Server <-> Archivierer Kommunikation
	\item Netzwerkkommunikation
	\begin{itemize}
		\item Struct vor Senden Serialisieren
		\item Nach Empfang wieder umwandeln
	\end{itemize}
\end{itemize}

\subsection{Programmstart}
Das Programm wird aus der Konsole gestartet. Es müssen folgende Parameter angegeben werden:
\begin{itemize}
	\item Port
\end{itemize}

\paragraph{Beispiel:}
\code{> ./server 8080}

\subsection{Strukturen (intern)}
\subsubsection{Benutzerrollen}
\begin{lstlisting}
enum ROLE {
    Dozent = 1
    Tutor = 2
    Student = 3
};
\end{lstlisting}

\subsubsection{Clientliste}
\begin{lstlisting}
struct CLIENTLIST {
    int sockd;
    char name[25];
    enum ROLE role;
    /*
     * Modify 0 -> nur lesend
     * Modify 1 -> schreibzugriff (exclusiv)
     */
    int modify;
    struct CLIENTLIST *previous;
    struct CLIENTLIST *next;
}
\end{lstlisting}

\subsubsection{Tafel}
\begin{lstlisting}
/* 
 * 14 * 79 Zeichen + /n
 * 1 * 79 Zeichen + /0
 * >>> als Shared Memory anlegen
 */
char blackboard[15][80];
\end{lstlisting}

\subsection{Abläufe}

\subsubsection{Programmstart}
\begin{lstlisting}
# Sicherstellen, dass noch kein Server läuft
# Mutex für Tafelzugriff initialisieren (gesperrt)
# Mutex für Zugriff auf Client-Liste initialisieren (gesperrt)
# Initialisierung der Tafel (Shared Memory)
# Initialisierung der Client-Liste (doppelt verkettete Liste)
# Initialisierung Semaphore (Zähler) für aktive Clients (*** GEEIGNET??? ***)
# Message Queue für Logging initialisieren
# Initialisiere Trigger für Broadcasting-Agent (*** IMPLEMENTIERUNG??? ***)
# Initialisiere Trigger "Tafel archiviert" (Condition Variable > pthread)
# Signal registrieren für "System beenden"
# Socket für Netzwerkkommunikation öffnen

# Fork: Logger (externes Programm)
# Fork: Archivierer (externes Programm), wenn Debugmodus mit Archivierungsintervall
# Starte Broadcasting-Agent als Thread
# Starte Login-Thread
# Mutex für Tafelzugriff freigeben
# Mutex für Clientliste freigeben
\end{lstlisting}

\subsubsection{Signal System beenden}
\begin{lstlisting}
# Mutex-Down: Clientliste
    # Kill: Login-Thread
# Mutex-Up: Clientliste
# Trigger Broadcasting Agent: Clients beenden (quit)
# Warte auf Sempahore (Clientzähler) == 0 (*** GEEIGNET??? ***)
    # Kill: Broadcasting Agent
# Netzwerksocket schließen
# Kill: Archivierer
# Kill: Logger
# Message Queue (Logger) löschen
# Mutex-Down: Tafel
# Freigabe: Shared Memory (Tafel)
\end{lstlisting}

\subsubsection{Login-Thread}
\begin{lstlisting}
# Warte auf Login von Client
# Mutex-Down für Zugriff auf Client-Liste 
    # Prüfung: Clientname bereits in Liste?
        # wenn Ja: Fehlermeldung an Client
    # Schreibrecht: Nein
    # Wenn Rolle Dozent: Prüfung, bereits ein Dozent angemeldet?
        # wenn Ja: ändere Rolle Dozent -> Student
        # wenn Nein: Schreibrecht zuweisen
    # Wenn Rolle Tutor: ändere Rolle zu Student
    # (IP/DNS-Name,) Client-Name, Rolle + Zugriffsrecht in Liste eintragen
    # Semaphore (Clientzähler) Up
# Mutex-Up für Zugriff auf Client-Liste
# Starte Client-Thread für neuen Client
# Trigger Broadcasting-Agent: Update Anzahl Clients
\end{lstlisting}

\subsubsection{Client-Thread}
\begin{lstlisting}
# Rückmeldung an Client: Login erfolgreich
# Warte auf Befehle von verbundenem Client
> quit (Client beenden) bzw. Client schließt Verbindung
    # Mutex-Down für Zugriff auf Client-Liste
        # Client aus Client-Liste austragen
        # Semaphore (Client-Zähler) Down
    # Mutex-Up
    # Trigger Broadcasting-Agent: Sende neue Clientanzahl
    # Tread beenden
> request (Schreibrechte anfordern)
    # Mutex-Down für Zugriff auf Client-Liste
        # hat Client bereits schreibrecht bzw. ist Dozent?
            # wenn Ja: Fehlermeldung
        # suche Dozent in Clientliste
            # kein Dozent: Fehlermeldung
    # Mutex-Up
    # Anfrage für Schreibrecht an Dozent
    # Warte auf Antwort von Dozent
        # Antwort Nein: Fehlermeldung an anfragenden Benutzer
    # Mutex-Down für Zugriff auf Client-Liste
        # setze alter Benutzer mit Schreibrechten: keine Schreibrechte
        # aktueller Benutzer: Schreibrecht
    # Mutex-Up
    # Statusänderung alter Benutzer: keine Schreibrechte
    # Statusänderung anfragender Benutzer: Schreibrechte    
    # Trigger Broadcasting-Agent: Tutor = 1
> shutdown
    # Mutex-Down für Zugriff auf Client-Liste
        # Benuter ist Dozent?
            # wenn Nein: Fehlermeldung
    # Mutex-Up
    # Signal senden: System beenden
> release
    # Mutex-Down für Zugriff auf Client-Liste
        # Benutzer ist Tutor?
            # wenn Nein: Fehlermeldung
        # aktueller Benutzer: Schreibrecht > Nein
        # ändere Rolle Tutor -> Student
        # Dozent: Schreibrecht Ja
    # Mutex-Up
    # Trigger Broadcasting-Agent: Tutoren = 0
    # Sende Statusänderung Dozent: Schreibrecht erhalten
> acquire
    # Mutex-Down für Zugriff auf Client-Liste
        # aktueller Benutzer ist Dozent?
            # wenn Nein: Fehlermeldung
        # entziehe Tutor Schreibrecht
        # setze Dozent Schreibrecht
    # Mutex-Up
    # Statusänderung vorheriger Tutor: keine Schreibrechte
    # Trigger Broadcasting-Agent: Tutoren = 0
    # Sende Statusänderung Dozent: Schreibrechte
> modify
    # Mutex-Down für Zugriff auf Client-Liste
        # Benutzer hat Schreibrechte?
            # wenn Nein: Fehlermeldung
    # Mutex-Up
    # Mutex-Down für Zugriff auf Tafel
        # Änderungen in Shared Memory schreiben
    # Mutex-Up
    # Trigger Broadcasting-Agent: Tafeländerung
> clear
    # Mutex-Down für Zugriff auf Client-Liste
        # Benutzer hat Schreibrechte?
            # wenn Nein: Fehlermeldung
    # Mutex-Up
    # Mutex-Down für Zugriff auf Tafel
    # Trigger Archivierer
        *** Im Archivierer ist kein Mutex-Down notwendig. Dies erfolgt vor
        *** der Triggerung des Archivierers, um sicherzustellen, das in der
        *** Zwischenzeit niemand anders auf die Tafel zugreift.
        *** Der Archivierer macht nach dem Sichern der Tafel einen Mutex-Up
    # Mutex-Down für Zugriff auf Tafel
        # Lösche Tafel  
    # Mutex Up
    # Trigger Broadcasting-Agent: Tafel leer
\end{lstlisting}

\subsubsection{Broadcasting-Agent (Thread)}
\begin{lstlisting}
# Warte auf Trigger
# Wenn Tafeländerung
    # Mutex-Down für Zugriff auf Tafel
        # Lese Tafelinhalt
    # Mutex-Up
# Sende Nachricht an alle verbundenen Clients
\end{lstlisting}

\subsection{Logger}
\begin{lstlisting}
# Öffne Message Queue
# Warte auf Messages
# Schreibe Zeitstempel + Nachricht in Datei (zeilenweise)
\end{lstlisting}

\subsection{Archivierer}
\begin{lstlisting}
# Öffne Logfile (schreibbar)
# Warte auf Trigger bzw. Ablauf von Timer (Debug-Modus)
# Ausgelöst durch Timer?
    # wenn Ja: Mutex
    *** Vor dem Auslesen der Tafel ist nur ein Mutex-Down notwendig, wenn
    *** der Auslöser für die Archivierung durch den Timer erfolgt ist.
    *** Andernfalls ist dies bereits durch den Client-Thread geschehen um
    *** sicherzustellen, dass der Tafelinhalt erst nach dem Archivieren
    *** gelöscht wird.
# Tafel auslesen
# Mutex-Up
# Zeitstempel + Tafelinhalt in Datei schreiben (blockweise)
\end{lstlisting}
